#!/bin/sh
. /lib/functions.sh
. /lib/functions/system.sh


# initialize defaults
RAMFS_COPY_BIN=""	# extra programs for temporary ramfs root
RAMFS_COPY_DATA=""	# extra data files
export MTD_CONFIG_ARGS=""
export INTERACTIVE=0
export VERBOSE=1
export SAVE_CONFIG=1
export SAVE_OVERLAY=0
export DELAY=
export CONF_IMAGE=
export CONF_BACKUP_LIST=0
export CONF_BACKUP=
export CONF_SELECTED_BACKUP=
export CONF_UCI_BACKUP=
export CONF_RESTORE=
export NEED_IMAGE=
export HELP=0
export FORCE=0
export TEST=0
export PROVFILE=provisioning.conf
export SYSCONFILE=/etc/sysupgrade.conf
export TMPDIR=/tmp
USB=0
ONLINE=0

# parse options
while [ -n "$1" ]; do
	case "$1" in
		-i) export INTERACTIVE=1;;
		-d) export DELAY="$2"; shift;;
		-v) export VERBOSE="$(($VERBOSE + 1))";;
		-q) export VERBOSE="$(($VERBOSE - 1))";;
		-n) export SAVE_CONFIG=0;;
		-c) export SAVE_OVERLAY=1;;
		-b|--create-backup) export CONF_BACKUP="$2" NEED_IMAGE=1; shift;;
		-s|--create-backup-selected) export CONF_SELECTED_BACKUP="$2" NEED_IMAGE=1; shift;;
		-u|--create-backup-uci) export CONF_UCI_BACKUP="$2" NEED_IMAGE=1; shift;;
		-r|--restore-backup) export CONF_RESTORE="$2" NEED_IMAGE=1; shift;;
		-l|--list-backup) export CONF_BACKUP_LIST=1; break;;
		-p|--password) if [ "$2" = "" ]; then echo "Can not have empty password!"; exit 1; fi; export CONF_PASSWORD="$2"; shift;;
		-f) export CONF_IMAGE="$2"; shift;;
		-F|--force) export FORCE=1;;
		-T|--test) export TEST=1;;
		--usb) USB=1; break;;
		--online) ONLINE=1; break;;
		-h|--help) export HELP=1; break;;
		-*)
			echo "Invalid option: $1"
			exit 1
		;;
		*) break;;
	esac
	shift;
done

# just one instance
if [ -e /tmp/sysupgrade.lock ]
then
    echo "Another instance of sysupgrade already running"
    exit 1
fi

lock /var/sysupgrade.lock
# make REALLY sure the file is removed
finish() {
    lock -u /var/sysupgrade.lock
    # just in case really remove it
    rm -f /var/sysupgrade.lock
}
trap finish EXIT INT TERM

export CONFFILES=/tmp/sysupgrade.conffiles
export CONF_TAR=/sysupgrade.tgz

export ARGV="$*"
export ARGC="$#"

find_image_on_usb() {
	local image
	local extension=$(uci -q get system.@upgrade[0].fw_find_ext)
	extension=${extension:-.y2}

	image=$(find /mnt/ -name "*$extension" | sed -E 's/.*-([0-9]{6})_.*/\0 \1/gi' | sort -k 2 | head -n1 | cut -d' ' -f1)
	if [ -n "${image}" ]; then
		ARGV=${image}
	else
		ARGV=""
	fi
}
 
online_fw_check() {
	local imgver curver imgurl
	local verpath="/tmp/fw_online_version"
	local urlpath="/tmp/fw_online_url"
	local checkurl=$(uci -q get system.@upgrade[0].fw_check_url)
	local pathurl=$(uci -q get system.@upgrade[0].fw_path_url)
	local extension=$(uci -q get system.@upgrade[0].fw_find_ext)
	extension=${extension:-.y}

	[ -n "$checkurl" ] || exit 1
	[ -n "$pathurl" ] || exit 1

	rm -f $verpath
	rm -f $urlpath

	wget -q -t 3 $checkurl -O $verpath

	[ -f $verpath ] || exit 1

	imgver=$(cat $verpath)
		[ -z "$imgver" ] && exit 1
        case $imgver in
		*.w|*.y|*.y2|*_fs_image) ;;
		*) imgver=$imgver$extension ;;
	esac

	curver="$(db get hw.board.iopVersion)$extension"

	if [ "$imgver" != "$curver" ]; then
		echo "$pathurl/$imgver"> $urlpath
		ARGV="$pathurl/$imgver"
	else
		ARGV=""
	fi
}

# if option --usb or --online, set ARGV accordingly.
if [[ ${USB} -eq 1 ]]; then
	find_image_on_usb
	[ -n "$ARGV" ] && echo "${ARGV}"
	exit 0
elif [[ ${ONLINE} -eq 1 ]]; then
	online_fw_check
	[ -n "$ARGV" ] && echo "${ARGV}"
	exit 0
fi

# always add complete path to argument and move to / directory
if [ -n "$ARGV" ]; then
	[ "$(dirname $ARGV)" == "." ] && ARGV="$PWD/$(basename $ARGV)"
fi
cd /

[ -z "$ARGV" -a -z "$NEED_IMAGE" -o $HELP -gt 0 ] && {
	cat <<EOF
Usage: $0 [<upgrade-option>...] <image file or URL>
       $0 [-q] [-i] <backup-command> <file>

upgrade-option:
	-d <delay>   add a delay before rebooting
	-f <config>  restore configuration from .tar.gz (file or url)
	-i           interactive mode
	-c           attempt to preserve all changed files in at least /etc/ (copy overlay)
	-n           do not save configuration over reflash
	-T | --test
	             Verify image and config .tar.gz but do not actually flash.
	-F | --force
	             Flash image even if image checks fail, this is dangerous!
	-q           less verbose
	-v           more verbose
	-h | --help  display this help

backup-command:
	-b | --create-backup <file>
	             create .tar.gz of files specified in sysupgrade.conf
	             then exit. Does not flash an image. If file is '-',
	             i.e. stdout, verbosity is set to 0 (i.e. quiet).
	-s | --create-backup-selected <file>
	             create .tar.gz of selected services/settings in /etc/config/backup
	             then exit. Does not flash an image. If file is '-',
	             i.e. stdout, verbosity is set to 0 (i.e. quiet).
	-r | --restore-backup <file>
	             restore a .tar.gz created with sysupgrade -b
	             then exit. Does not flash an image. If file is '-',
	             the archive is read from stdin.
	-l | --list-backup
	             list the files that would be backed up when calling
	             sysupgrade -b. Does not create a backup file.

	-u| --create-backup-uci <file>  create .tar.gz of uci export command
	             then exit. Does not flash an image. If file is '-',
	             i.e. stdout, verbosity is set to 0 (i.e. quiet).
	-p| --password <pass> specify backup file password. 
EOF
	exit 1
}

[ -n "$ARGV" -a -n "$NEED_IMAGE" ] && {
	cat <<-EOF
		-b|--create-backup and -r|--restore-backup do not perform a firmware upgrade.
		Do not specify both -b|-r and a firmware image.
	EOF
	exit 1
}

# prevent messages from clobbering the tarball when using stdout
[ "$CONF_BACKUP" = "-" ] && export VERBOSE=0
[ "$CONF_SELECTED_BACKUP" = "-" ] && export VERBOSE=0

add_uci_backup_files() {
	local FILES=""
	local f=""

	save_selected_backup_files() {
		config_get keep $1 keep "1"
		if [ "$keep" == "1" ]; then
			config_get file "$1" file
			for f in $file; do
				FILES="$FILES $f"
			done
		fi
	}

	#echo "UCI backup"
	config_load backup
	config_foreach save_selected_backup_files service

	#echo "Read from $SYSCONFILE"
	while read -r f
	do
		case $f in
			/*) FILES="$FILES $f";;
		esac
	done < "$SYSCONFILE"
	FILES="$FILES $SYSCONFILE"

	#echo "finding files that differ from base install..."
	for item in $FILES
	do
		if [ -e "$item" ]; then
			cmp -s "$item" "/rom/$item" || {
				#echo "backing up $item"
				echo "$item" >> "$1"
			}
		fi
	done
	return 0
}

# hooks
sysupgrade_image_check="platform_check_image"
sysupgrade_init_conffiles="add_uci_backup_files"

include /lib/upgrade

[ "$1" = "nand" ] && nand_upgrade_stage2 $@

do_save_conffiles() {
	local conf_tar="${1:-$CONF_TAR}"

	local tmpfolder="/tmp/__backup_configs__"
	mkdir -p $tmpfolder
	cp -rp /etc/config/* $tmpfolder/
	/etc/init.d/enviroment macro

	[ -z "$(rootfs_type)" ] && {
		echo "Cannot save config while running from ramdisk."
		ask_bool 0 "Abort" && exit
		return 0
	}
	run_hooks "$CONFFILES" $sysupgrade_init_conffiles
	ask_bool 0 "Edit config file list" && vi "$CONFFILES"

	v "Saving config files..."
	[ "$VERBOSE" -gt 1 ] && TAR_V="v" || TAR_V=""
	
	# do special case for stdout target
	if [ "$conf_tar" = "-" ]; then 
		if [ -n "$CONF_PASSWORD" ]; then 
			(tar c${TAR_V}zf "$conf_tar" -T "$CONFFILES" | openssl des3 -pass pass:"$CONF_PASSWORD") 2>/dev/null
		else 
			tar c${TAR_V}zf "$conf_tar" -T "$CONFFILES" 2>/dev/null
		fi
	else # output is a file
		tar c${TAR_V}zf "$conf_tar" -T "$CONFFILES" 2>/dev/null
		
		if [ -n "$CONF_PASSWORD" ]; then 
			openssl des3 -in "$conf_tar" -out "$conf_tar.enc" -pass pass:"$CONF_PASSWORD" 2>/dev/null
			mv "$conf_tar.enc" "$conf_tar"
		fi
	fi
	cp -rp $tmpfolder/* /etc/config/
	rm -rf $tmpfolder

	rm -f "$CONFFILES"
}

do_save_selected_conffiles() {
	local conf_tar="${1:-$CONF_TAR}"

	local tmpfolder="/tmp/__backup_configs__"
	mkdir -p $tmpfolder
	cp -rp /etc/config/* $tmpfolder/
	/etc/init.d/enviroment macro

	save_selected() {
		config_get keep "$1" keep "1"
		if [ "$keep" == "1" ]; then
			config_get file "$1" file
			for f in $file; do
				echo $f >> /tmp/selected_backup_files
			done
		fi
	}

	config_load backup
	config_foreach save_selected service

	v "Saving config files ..."
	[ "$VERBOSE" -gt 1 ] && TAR_V="v" || TAR_V=""

	if [ -f /tmp/backup_target_mntdir ]; then
		local mntdir="$(cat /tmp/backup_target_mntdir)"
		local btgz="backup-$(cat /proc/sys/kernel/hostname)-$(date +%Y-%m-%d).tar.gz"
		if [ -n "$mntdir" ] && [ "$mntdir" != "/mnt/" ] && [ -d $mntdir ]; then
			tar c${TAR_V}z "$conf_tar" -T /tmp/selected_backup_files -f $mntdir$btgz 2>/dev/null
			sync
		fi
		rm -f /tmp/backup_target_mntdir
	else
		tar c${TAR_V}zf "$conf_tar" -T /tmp/selected_backup_files 2>/dev/null
	fi
	rm -f /tmp/selected_backup_files

	cp -rp $tmpfolder/* /etc/config/
	rm -rf $tmpfolder
}

do_save_conffiles_uci() {
	local conf_tar="${1:-$CONF_TAR}"

	local tmpfolder="/tmp/__backup_configs__"
	mkdir -p $tmpfolder
	cp -rp /etc/config/* $tmpfolder/
	/etc/init.d/enviroment macro

	[ -z "$(rootfs_type)" ] && {
		echo "Cannot save config while running from ramdisk."
		ask_bool 0 "Abort" && exit
		return 0
	}
	uci export > $TMPDIR/$PROVFILE
	

	#v "Saving UCI export ..."
	[ "$VERBOSE" -gt 1 ] && TAR_V="v" || TAR_V=""
	tar c${TAR_V}zf "$conf_tar" -C $TMPDIR $PROVFILE 2>/dev/null
	rm -rf $TMPDIR/$PROVFILE

	cp -rp $tmpfolder/* /etc/config/
	rm -rf $tmpfolder
}


if [ $CONF_BACKUP_LIST -eq 1 ]; then
	add_uci_backup_files "$CONFFILES"
	cat "$CONFFILES"
	rm -f "$CONFFILES"
	exit 0
fi

if [ -n "$CONF_BACKUP" ]; then
	do_save_conffiles "$CONF_BACKUP"
	exit $?
fi

if [ -n "$CONF_SELECTED_BACKUP" ]; then
	do_save_selected_conffiles "$CONF_SELECTED_BACKUP"
	exit $?
fi

if [ -n "$CONF_UCI_BACKUP" ]; then
	do_save_conffiles_uci "$CONF_UCI_BACKUP"
	exit $?
fi

if [ -n "$CONF_RESTORE" ]; then
	if [ "$CONF_RESTORE" != "-" ] && [ ! -f "$CONF_RESTORE" ]; then
		echo "Backup archive '$CONF_RESTORE' not found."
		exit 1
	fi

	if [ -n "$CONF_PASSWORD" ]; then 
		openssl des3 -d -in "$CONF_RESTORE" -out "$CONF_RESTORE.dec" -pass pass:"$CONF_PASSWORD"
		if [ $? -eq 0 ]; then
			mv "$CONF_RESTORE.dec" "$CONF_RESTORE"
		else 
			echo "Could not decrypt backup!"
			exit 1
		fi
	fi

	[ "$VERBOSE" -gt 1 ] && TAR_V="v" || TAR_V=""
	tar -C / -x${TAR_V}zf "$CONF_RESTORE"

	local extraction_failed="$?"
	if [ "$extraction_failed" == "1" ]; then
		echo "Backup decompression failed! Backup might be password protected."
		exit 1
	fi
	exit 0
fi

type platform_check_image >/dev/null 2>/dev/null || {
	echo "Firmware upgrade is not implemented for this platform."
	exit 1
}

for check in $sysupgrade_image_check; do
	( eval "$check \"\$ARGV\"" ) || {
		if [ $FORCE -eq 1 ]; then
			echo "Image check '$check' failed but --force given - will update anyway!"
			break
		else
			ubus send "sysupgrade" "{\"status\":\"failed\", \"test\":\"$check\"}"
			echo "Image check '$check' failed."
			exit 1
		fi
	}
done


if [ -n "$CONF_IMAGE" ]; then
	case "$(get_magic_word $CONF_IMAGE cat)" in
		# .gz files
		1f8b) ;;
		*)
			echo "Invalid config file. Please use only .tar.gz files"
			ubus send "sysupgrade" "{\"status\":\"failed\", \"reason\":\"Invalid config file\"}"
			exit 1
		;;
	esac
	get_image "$CONF_IMAGE" "cat" > "$CONF_TAR"
	export SAVE_CONFIG=1
elif ask_bool $SAVE_CONFIG "Keep config files over reflash"; then
	[ $TEST -eq 1 ] || do_save_conffiles
	export SAVE_CONFIG=1
else
	export SAVE_CONFIG=0
fi

if [ $TEST -eq 1 ]; then
	exit 0
fi
ubus send "sysupgrade" "{\"status\":\"success\"}"

run_hooks "" $sysupgrade_pre_upgrade

# Some platforms/devices may want different sysupgrade process, e.g. without
# killing processes yet or calling ubus system upgrade method.
# This is needed e.g. on NAND devices where we just want to trigger stage1 at
# this point.
if type 'platform_pre_upgrade' >/dev/null 2>/dev/null; then
	platform_pre_upgrade "$ARGV"
fi

ubus call system upgrade > /dev/null
touch /tmp/sysupgrade

if [ ! -f /tmp/failsafe ] ; then
	kill_network
	sleep 1
	kill_remaining TERM
	sleep 3
	kill_remaining KILL
fi

if [[ $(cat /tmp/IS_NAND) -eq 0 && -n "$(rootfs_type)" ]]; then
	v "Switching to ramdisk..."
	run_ramfs '. /lib/functions.sh; include /lib/upgrade; do_upgrade'
else
	do_upgrade
fi
